import { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';
import { useEffect } from 'react';
import {
  $getSelection,
  $isRangeSelection,
  $getRoot,
  COMMAND_PRIORITY_HIGH,
  COMMAND_PRIORITY_LOW,
  KEY_ENTER_COMMAND,
  KEY_TAB_COMMAND,
  PASTE_COMMAND,
  INSERT_PARAGRAPH_COMMAND,
  INSERT_LINE_BREAK_COMMAND,
  SELECTION_CHANGE_COMMAND,
  CONTROLLED_TEXT_INSERTION_COMMAND,
  LexicalNode,
  ElementNode,
  $isElementNode
} from 'lexical';
import { $isCollapsibleContainerNode } from './CollapsibleNode';
import { $isCollapsibleContentNode } from './CollapsibleContentNode';
import { $isCollapsibleTitleNode } from './CollapsibleTitleNode';
import { $isHeaderFieldNode, HeaderFieldNode } from './HeaderFieldNode';

// Plugin que protege contra edi√ß√£o fora dos containers colaps√≠veis
export default function EditProtectionPlugin(): null {
  const [editor] = useLexicalComposerContext();

  useEffect(() => {
    // Flag para controlar se a prote√ß√£o est√° ativa
    let protectionActive = false;
    
    // Verificar se o foco est√° em um input do header field
    const isHeaderFieldInputFocused = () => {
      const activeElement = document.activeElement;
      return activeElement?.getAttribute('data-header-field-input') === 'true';
    };
    
    // Ativar prote√ß√£o ap√≥s 5 segundos para permitir foco inicial e carregamento completo
    const activationTimeout = setTimeout(() => {
      protectionActive = true;
      console.log('üõ°Ô∏è EditProtectionPlugin: Prote√ß√£o ativada ap√≥s delay inicial de 5s');
    }, 5000);
    
    // Fun√ß√£o para verificar se a sele√ß√£o atual est√° dentro de um container colaps√≠vel
    const isSelectionInValidContainer = (): boolean => {
      const selection = $getSelection();
      if (!$isRangeSelection(selection)) {
        return false;
      }

      const anchor = selection.anchor.getNode();
      const focus = selection.focus.getNode();
      
      // Verificar se ambos os pontos da sele√ß√£o est√£o em containers v√°lidos
      return isNodeInValidContainer(anchor) && isNodeInValidContainer(focus);
    };

    // Fun√ß√£o para verificar se um n√≥ est√° dentro de um container colaps√≠vel v√°lido
    const isNodeInValidContainer = (node: LexicalNode): boolean => {
      let currentNode: LexicalNode | null = node;
      
      while (currentNode) {
        // Se estamos diretamente em um CollapsibleContentNode, permitir edi√ß√£o
        if ($isCollapsibleContentNode(currentNode)) {
          return true;
        }
        
        // Se estamos em um HeaderFieldNode ou seus filhos, permitir edi√ß√£o
        if ($isHeaderFieldNode(currentNode)) {
          return true;
        }
        
        // Se chegamos ao root sem encontrar um n√≥ v√°lido, bloquear
        if (currentNode === $getRoot()) {
          // Verificar se o n√≥ original est√° dentro de um HeaderFieldNode
          let parent = node.getParent();
          while (parent && parent !== $getRoot()) {
            if ($isHeaderFieldNode(parent)) {
              return true;
            }
            parent = parent.getParent();
          }
          return false;
        }
        
        // Subir na hierarquia
        currentNode = currentNode.getParent();
      }
      
      return false;
    };

    // Comando para interceptar tentativas de inser√ß√£o de par√°grafo
    const handleInsertParagraph = () => {
      if (!protectionActive) return false; // Permitir durante grace period
      
      editor.update(() => {
        if (!isSelectionInValidContainer()) {
          console.log('üö´ Edi√ß√£o bloqueada: tentativa de inserir par√°grafo fora de container');
          return true; // Bloquear comando
        }
      });
      return false; // Permitir comando
    };

    // Comando para interceptar Enter
    const handleEnterKey = (): boolean => {
      if (!protectionActive) return false; // Permitir durante grace period
      
      let shouldBlock = false;
      editor.update(() => {
        if (!isSelectionInValidContainer()) {
          console.log('üö´ Edi√ß√£o bloqueada: tentativa de usar Enter fora de container');
          shouldBlock = true;
        }
      });
      return shouldBlock;
    };

    // Comando para interceptar Tab
    const handleTabKey = (): boolean => {
      if (!protectionActive) return false; // Permitir durante grace period
      
      let shouldBlock = false;
      editor.update(() => {
        if (!isSelectionInValidContainer()) {
          console.log('üö´ Edi√ß√£o bloqueada: tentativa de usar Tab fora de container');
          shouldBlock = true;
        }
      });
      return shouldBlock;
    };

    // Comando para interceptar Paste
    const handlePaste = (): boolean => {
      if (!protectionActive) return false; // Permitir durante grace period
      
      let shouldBlock = false;
      editor.update(() => {
        if (!isSelectionInValidContainer()) {
          console.log('üö´ Edi√ß√£o bloqueada: tentativa de colar fora de container');
          shouldBlock = true;
        }
      });
      return shouldBlock;
    };

    // Vari√°vel para rastrear se estamos digitando
    let isTyping = false;
    let typingTimeout: NodeJS.Timeout | null = null;
    
    // Interceptar mudan√ßas de sele√ß√£o para posicionar cursor adequadamente
    const handleSelectionChange = () => {
      // N√£o fazer nada se a prote√ß√£o ainda n√£o est√° ativa
      if (!protectionActive) return;
      
      // Se estamos digitando, n√£o reposicionar o cursor
      if (isTyping) return;
      
      // Se o foco est√° em um input do header field, n√£o interferir
      if (isHeaderFieldInputFocused()) return;
      
      // Verificar se clicamos em um bot√£o - n√£o interferir com cliques em bot√µes
      const activeElement = document.activeElement;
      if (activeElement?.tagName === 'BUTTON' || activeElement?.closest('button')) {
        return;
      }
      
      editor.update(() => {
        const selection = $getSelection();
        if ($isRangeSelection(selection)) {
          const anchor = selection.anchor.getNode();
          
          // Se a sele√ß√£o est√° fora de um container v√°lido E n√£o √© uma sele√ß√£o colapsada (cursor),
          // mover para o primeiro container v√°lido
          if (!isNodeInValidContainer(anchor) && selection.isCollapsed()) {
            const root = $getRoot();
            let firstValidContainer: LexicalNode | null = null;
            let firstHeaderField: HeaderFieldNode | null = null;
            
            // Buscar primeiro por HeaderFieldNodes
            const findFirstEditableArea = (node: LexicalNode): void => {
              // Priorizar HeaderFieldNodes
              if ($isHeaderFieldNode(node) && !firstHeaderField) {
                firstHeaderField = node as HeaderFieldNode;
                return;
              }
              
              // Se n√£o encontrou HeaderField, buscar CollapsibleContentNode
              if ($isCollapsibleContentNode(node) && !firstValidContainer && !firstHeaderField) {
                firstValidContainer = node;
                return;
              }
              
              if ($isElementNode(node)) {
                const children = node.getChildren();
                for (const child of children) {
                  findFirstEditableArea(child);
                  if (firstHeaderField) break; // Parar se encontrou HeaderField
                }
              }
            };
            
            findFirstEditableArea(root);
            
            // Priorizar HeaderField se encontrado
            if (firstHeaderField) {
              console.log('üìç Focando em HeaderField');
              // N√£o fazer nada aqui - deixar o campo do header manter seu foco natural
              // Os campos do header gerenciam seu pr√≥prio foco atrav√©s de seus inputs
            } else if (firstValidContainer && $isElementNode(firstValidContainer)) {
              const elementNode = firstValidContainer as ElementNode;
              const firstChild = elementNode.getFirstChild();
              if (firstChild) {
                firstChild.selectStart();
                console.log('üìç Cursor reposicionado para √°rea edit√°vel v√°lida');
              }
            }
          }
        }
      });
    };
    
    // Detectar quando o usu√°rio est√° digitando
    const handleBeforeInput = () => {
      isTyping = true;
      
      // Limpar timeout anterior se existir
      if (typingTimeout) {
        clearTimeout(typingTimeout);
      }
      
      // Definir novo timeout para resetar flag de digita√ß√£o
      typingTimeout = setTimeout(() => {
        isTyping = false;
      }, 500); // 500ms ap√≥s parar de digitar
      
      return false; // Permitir input normal
    };

    // Registrar comandos com alta prioridade para interceptar antes de outros plugins
    const unregisterInsertParagraph = editor.registerCommand(
      INSERT_PARAGRAPH_COMMAND,
      handleInsertParagraph,
      COMMAND_PRIORITY_HIGH
    );

    const unregisterEnter = editor.registerCommand(
      KEY_ENTER_COMMAND,
      handleEnterKey,
      COMMAND_PRIORITY_HIGH
    );

    const unregisterTab = editor.registerCommand(
      KEY_TAB_COMMAND,
      handleTabKey,
      COMMAND_PRIORITY_HIGH
    );

    const unregisterPaste = editor.registerCommand(
      PASTE_COMMAND,
      handlePaste,
      COMMAND_PRIORITY_HIGH
    );

    const unregisterLineBreak = editor.registerCommand(
      INSERT_LINE_BREAK_COMMAND,
      handleInsertParagraph,
      COMMAND_PRIORITY_HIGH
    );

    // Registrar handler para detectar quando est√° digitando
    const unregisterTextInsertion = editor.registerCommand(
      CONTROLLED_TEXT_INSERTION_COMMAND,
      () => {
        handleBeforeInput();
        return false; // Permitir inser√ß√£o de texto normal
      },
      COMMAND_PRIORITY_HIGH
    );
    
    // TEMPORARIAMENTE DESABILITADO: Est√° interferindo com os campos do header
    // Monitorar apenas mudan√ßas de sele√ß√£o (n√£o a cada keystroke)
    /*
    const unregisterSelectionListener = editor.registerCommand(
      SELECTION_CHANGE_COMMAND,
      () => {
        handleSelectionChange();
        return false; // Permitir que outros listeners processem o comando
      },
      COMMAND_PRIORITY_LOW
    );
    */

    console.log('‚úÖ Plugin de prote√ß√£o de edi√ß√£o ativado');

    // Cleanup
    return () => {
      clearTimeout(activationTimeout);
      if (typingTimeout) {
        clearTimeout(typingTimeout);
      }
      unregisterInsertParagraph();
      unregisterEnter();
      unregisterTab();
      unregisterPaste();
      unregisterLineBreak();
      unregisterTextInsertion();
      // unregisterSelectionListener(); // Desabilitado temporariamente
    };
  }, [editor]);

  return null;
}